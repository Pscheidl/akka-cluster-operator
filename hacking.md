# Developer guide

Assumed background: Kubernetes controllers, operator-sdk or similar, custom resource definitions

## Concept map

The AkkaCluster operator is similar in concept to a Deployment controller, in that it
watches for a top level resource then drives changes down into sub-resources. So just like
a Deployment drives changes into a ReplicaSet, the AkkaCluster drives changes into a
Deployment, ServiceAccount, Role, and RoleBinding.

The `spec` of an AkkaCluster is just a Deployment spec, with a set of defaults that are
used if certain fields are blank. On the reconcile main loop, the AkkaCluster resource is
turned into an ideal specification for a set of sub-resources, which is the goal state.
In-cluster resources are then compared to the goal state, and created or updated as needed.

The `status` of an AkkaCluster is fed to the controller by a helper loop, run as an actor,
which is keeping a list of clusters, their leader endpoints, and their Akka Management
endpoint results. If the status actor sees a change, it pushes a reconcile event to the
main controller, where the change is picked up.

The above custom logic should hook pretty easily into any operator framework, and there's
nothing that particularly requires operator-sdk except where it is used to validate OLM
things. The heavy lifting outside of the above logic is all done in Kubernetes client
code. Since this area is a fast moving target, the main thought here was just to use the
native client libs which happen to be in go, so this is in go too. But this could all be
written in Scala if one wanted to be adventerous.

## Code map

### serde in ./pkg/apis/app/v1alpha1/

`akkacluster_types.go` is the primary source for serialization / deserialization. It has
go structures with json tags for all the AkkaCluster spec and status bits. If you change
things here, you must run "generate k8s" to regenerate all the various DeepCopy functions.

```sh
operator-sdk generate k8s
```

### controller in ./pkg/controller/akkacluster/

`akkacluster_controller.go` is the primary source for the controller, and is where
`Watch()` is called to set up reconcile triggers, and where `Reconcile()` is defined.

`deploy_builder.go` takes an AkkaCluster, fills in defaults, returns a set of ideal
resources.

`subset.go` is a generic SubsetEqual implementation, using reflection to support arbitrary
go structures. SubsetEqual(A,B) returns true if A is a subset of B. This is handy for
comparing pristine ideal resources with mucked in-cluster resources, ignoring all the
ephemera of live resources like timestamps, uids, and other run time housekeeping.

`status.go` is an actor responsible for polling cluster leaders for Akka Management
status. It provides status to Reconcile(), and triggers reconcile when it sees status
changes. It bootstraps in a way very similar to Akka Management, in that it uses the
AkkaCluster pod selector to list running pods and then starts talking to them to locate
the leader.

### deployment artifacts

`./deploy/*.yaml` is the operator Deployment, ServiceAccount, Role, and RoleBinding. These
were all generated by operator-sdk, meaning nothing special here, just generic operator
things.

`./deploy/crds/app_v1alpha1_akkacluster_crd.yaml` has the custom resource definition. This is where
new top level fields and basic validation go, if you want `kubectl` to know a valid from
invalid AkkaCluster.

`./deploy/old-catalog/` has a nested OLM package, which should be updated on releases. The
primary source here are the "*clusterserviceversion.yaml" files, one for each version published.

## Unit testing

The controller has several unit tests that can be run with the usual go tools.

```text
go test -race ./...
```

`akkacluster_controller_test.go` uses controller-runtime client mocks to emulate a
kubernetes environment behind the client interface.

`deploy_builder_test.go` uses a yamlizer and gold files to take input yaml, generate ideal
resources, compare to output yaml files. Gold file tests are a kind of regression test,
and may need to be updated if the schema changes or deploy builder defaults change.

To update gold files, run tests with the `-update` flag:

```text
go test -update ./...
```

`subset_test.go` has a mix of whitebox, blackbox, edge, and gold file tests. The whitebox
tests just say if the subset was found or not. The blackbox tests say how many nodes in
the object tree were compared equal, to ensure that the tree is walked completely. Edge
tests include various empty comparisons, off-by-one comparisons, and validates that short
circuit works on recursive objects. There is one gold file test against a complex
Deployment object found in OpenShift, with tons of extraneous fields to ignore.

`status_test.go` is a step toward property testing, with various generators for
AkkaClusters. It also defines a mock urlReader and podLister so the test can provide the
status actor with arbitrary cluster results. It then runs a status actor in high speed
mode and verifies that status changes are correctly signaled back to the controller.

## minikube loop

* install operator-sdk
* start minikube
* install the CRD
* route pod network to macbook so operator can query akka management endpoints

```sh
sudo route -n add 172.17.0.0/16 $(minikube ip)
```

then loop on:

* `operator-sdk up local`

and a demo app in minikube. This lets you run the operator locally, watch logs, watch
mutations to resources within minikube.

## GitHub Actions

CI/CD is done via GitHub Actions, as seen in `./.github/main.workflow`. PRs must pass unit
tests, and merges to master trigger goreportcard updates and docker image builds that get
pushed to bintray.

## OLM manifests

## OLM testing
